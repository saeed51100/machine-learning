Please think long and hard.
I am developing a time-series classification pipeline in Python (Jupyter Notebook) to identify Forex price trend regimes based on historical price data.
The dataset consists of approximately 170,000 rows of Forex OHLCV data on the H1 (hourly) timeframe, with the following characteristics:
* Dataset Description
    1- The main DataFrame df contains 140,000 rows and 10 columns:
        DATETIME, DATE, TIME, OPEN, HIGH, LOW, CLOSE, TICKVOL, VOL, SPREAD.
    2- Each row represents one hour of Forex price data.
    3- The dataset is fully continuous; all weekend and holiday gaps have already been forward-filled.
    4- The DATETIME column is strictly chronological and represents the true time index.

I have written code that adds a Label column to df_model to represent the dominant price trend:
    0 â†’ No meaningful trend (sideways / flat movement)
    1 â†’ Bullish trend
    2 â†’ Bearish trend

The current code works correctly and assigns labels 0 and 1 and 2 as intended.

* Question
Please make just one major code modification and write me the improved version.

// my code:
def label_trend_points(
        close,
        high=None,
        low=None,
        smoothing_window=31,
        polyorder=3,
        base_prom_factor=0.02,
        distance=3,
        snap_window=5,
        min_dev_pct=0.0015,
        min_dev_sigma=2.0,
        vol_window=100,
        flat_slope_window=10,
        flat_slope_mult=0.5,
        verbose=False
):
    import numpy as np
    from scipy.signal import savgol_filter, find_peaks, peak_prominences

    close = np.asarray(close, dtype=float)
    n = close.size
    labels = np.zeros(n, dtype=int)

    if n < 3:
        return labels

    # -------------------------------------------------------
    # NaN handling
    # -------------------------------------------------------
    if np.isnan(close).any():
        idx = np.arange(n)
        good = ~np.isnan(close)
        close = close.copy()
        close[~good] = np.interp(idx[~good], idx[good], close[good])

    # -------------------------------------------------------
    # EMA helper
    # -------------------------------------------------------
    def ema(x, span):
        alpha = 2.0 / (span + 1.0)
        out = np.empty_like(x)
        out[0] = x[0]
        for i in range(1, len(x)):
            out[i] = alpha * x[i] + (1 - alpha) * out[i - 1]
        return out

    # -------------------------------------------------------
    # Volatility proxy
    # -------------------------------------------------------
    ret = np.zeros(n)
    ret[1:] = np.abs(np.diff(close) / np.maximum(1e-12, close[:-1]))
    vol_absret = ema(ret, vol_window)
    local_vol_price = vol_absret * close

    # -------------------------------------------------------
    # Smoothing
    # -------------------------------------------------------
    win = min(smoothing_window, n - 1)
    if win % 2 == 0:
        win -= 1
    smoothed = savgol_filter(close, win, polyorder)

    global_std = np.std(close) or 1.0
    prom = global_std * base_prom_factor

    peak_idx, _ = find_peaks(smoothed, distance=distance, prominence=prom)
    val_idx, _ = find_peaks(-smoothed, distance=distance, prominence=prom)

    peak_prom = peak_prominences(smoothed, peak_idx)[0] if peak_idx.size else []
    val_prom = peak_prominences(-smoothed, val_idx)[0] if val_idx.size else []

    candidates = []
    for i, p in enumerate(peak_idx):
        candidates.append((int(p), 2, float(peak_prom[i])))
    for i, v in enumerate(val_idx):
        candidates.append((int(v), 1, float(val_prom[i])))

    candidates.sort(key=lambda x: x[0])
    if not candidates:
        return labels

    # -------------------------------------------------------
    # Enforce alternation
    # -------------------------------------------------------
    def enforce_alternation(ext):
        ext = ext[:]
        while True:
            changed = False
            i = 0
            while i < len(ext) - 1:
                if ext[i][1] == ext[i + 1][1]:
                    ext.pop(i if ext[i][2] < ext[i + 1][2] else i + 1)
                    changed = True
                else:
                    i += 1
            if not changed:
                break
        return ext

    candidates = enforce_alternation(candidates)

    # -------------------------------------------------------
    # Snap extrema
    # -------------------------------------------------------
    def snap(idx, typ):
        L = max(0, idx - snap_window)
        R = min(n, idx + snap_window + 1)
        if high is not None and low is not None:
            return L + (np.argmax(high[L:R]) if typ == 2 else np.argmin(low[L:R]))
        return L + (np.argmax(close[L:R]) if typ == 2 else np.argmin(close[L:R]))

    snapped = {}
    for idx, typ, pr in candidates:
        j = snap(idx, typ)
        if (j, typ) not in snapped or pr > snapped[(j, typ)][2]:
            snapped[(j, typ)] = (j, typ, pr)

    extrema = enforce_alternation(sorted(snapped.values(), key=lambda x: x[0]))

    # -------------------------------------------------------
    # Prune micro legs (unchanged logic)
    # -------------------------------------------------------
    final_ext = []
    for idx, typ, pr in extrema:
        if not final_ext:
            final_ext.append((idx, typ, pr))
            continue

        p_idx, _, _ = final_ext[-1]
        leg = abs(close[idx] - close[p_idx])
        thr = max(
            min_dev_pct * close[idx],
            min_dev_sigma * max(local_vol_price[idx], 1e-12)
        )

        if leg >= thr:
            final_ext.append((idx, typ, pr))

    if len(final_ext) < 2:
        return labels

    # =======================================================
    # ðŸ”¥ FINAL LABELING (CORRECT FLAT LOGIC)
    # =======================================================

    for i in range(len(final_ext) - 1):
        i0, t0, _ = final_ext[i]
        i1, t1, _ = final_ext[i + 1]

        # --- ORIGINAL TREND DIRECTION (UNCHANGED) ---
        if t0 == 1 and t1 == 2:
            base_label = 1
        elif t0 == 2 and t1 == 1:
            base_label = 2
        else:
            continue

        labels[i0:i1] = base_label
        labels[i0] = t0

    # =======================================================
    # ðŸ”¥ FINAL LABELING (CORRECT, NON-OVERWRITING)
    # =======================================================

    trend_labels = np.zeros(n, dtype=int)
    flat_mask = np.zeros(n, dtype=bool)

    # -------------------------------------------------------
    # 1ï¸âƒ£ Base trend labeling (unchanged logic)
    # -------------------------------------------------------
    for i in range(len(final_ext) - 1):
        i0, t0, _ = final_ext[i]
        i1, t1, _ = final_ext[i + 1]

        if t0 == 1 and t1 == 2:
            trend_labels[i0:i1] = 1
        elif t0 == 2 and t1 == 1:
            trend_labels[i0:i1] = 2

        trend_labels[i0] = t0

    # extend last trend
    last_idx, last_typ, _ = final_ext[-1]
    if last_idx < n - 1:
        trend_labels[last_idx:] = last_typ

    # -------------------------------------------------------
    # 2ï¸âƒ£ Flat detection (INDEPENDENT PASS)
    # -------------------------------------------------------
    win = flat_slope_window

    for j in range(win, n):
        seg = close[j - win:j + 1]

        # price range over window
        rng = seg.max() - seg.min()

        # volatility-aware flat threshold
        thr = flat_slope_mult * local_vol_price[j]

        if rng < thr:
            flat_mask[j - win:j + 1] = True

    # -------------------------------------------------------
    # 3ï¸âƒ£ Final labels: flat OVERRIDES trend
    # -------------------------------------------------------
    labels[:] = trend_labels
    labels[flat_mask] = 0

    if verbose:
        print("Label counts:",
              {k: int((labels == k).sum()) for k in [0, 1, 2]})
        print("Extrema kept:", len(final_ext))

    return labels
