I am developing a time-series classification pipeline in Python (Jupyter Notebook) to identify Forex price trend regimes based on historical price data.
The dataset consists of approximately 170,000 rows of Forex OHLCV data on the H1 (hourly) timeframe, with the following characteristics:
* Dataset Description
     The dataset contains a 'CLOSE' price column and a corresponding 'Label' column that indicates price trend events with three classes:
        0 → No meaningful trend (sideways / flat movement)
        1 → Bullish trend
        2 → Bearish trend


* Request
I have implemented a labeling function that assigns these labels based on price movements and successfully detects and labels major (large-scale) trends.
I now want to extend this same logic to additionally detect and label smaller-scale movements (sub-trends) that occur within larger trends, while preserving the current behavior and labels for major trends.
Please modify the code below to support multi-scale trend detection using the same underlying logic, and provide the complete, revised version of the code.
* Notes:
1- Each major trend may contain 0, 1, or 2 sub-trends.
2- Price fluctuations spanning 3 candles or fewer should be treated as noise and must not be labeled as sub-trends.

// My code:
def label_trend_points(
        close,
        high=None,
        low=None,
        smoothing_window=31,
        polyorder=3,
        base_prom_factor=0.02,
        distance=3,
        snap_window=5,
        min_dev_pct=0.0015,
        min_dev_sigma=2.0,
        vol_window=100,
        flat_slope_window=10,
        flat_slope_mult=0.5,
        verbose=False,
):
    close = np.asarray(close, dtype=float)
    n = len(close)
    labels = np.zeros(n, dtype=int)
    if n < 3:
        return labels

    # --------------------------------------------------
    # NaN handling
    # --------------------------------------------------
    if np.isnan(close).any():
        idx = np.arange(n)
        good = ~np.isnan(close)
        close = close.copy()
        close[~good] = np.interp(idx[~good], idx[good], close[good])

    # --------------------------------------------------
    # EMA + volatility proxy
    # --------------------------------------------------
    def ema(x, span):
        alpha = 2 / (span + 1)
        out = np.empty_like(x)
        out[0] = x[0]
        for i in range(1, len(x)):
            out[i] = alpha * x[i] + (1 - alpha) * out[i - 1]
        return out

    ret = np.zeros(n)
    ret[1:] = np.abs(np.diff(close) / np.maximum(1e-12, close[:-1]))
    local_vol_price = ema(ret, vol_window) * close

    # --------------------------------------------------
    # Smoothing + extrema detection
    # --------------------------------------------------
    win = min(smoothing_window, n - 1)
    if win % 2 == 0:
        win -= 1

    smoothed = savgol_filter(close, win, polyorder)
    prom = np.std(close) * base_prom_factor or 1e-12

    peaks, _ = find_peaks(smoothed, distance=distance, prominence=prom)
    vals, _ = find_peaks(-smoothed, distance=distance, prominence=prom)

    peak_prom = peak_prominences(smoothed, peaks)[0] if len(peaks) else []
    val_prom = peak_prominences(-smoothed, vals)[0] if len(vals) else []

    extrema = (
            [(i, 2, p) for i, p in zip(peaks, peak_prom)] +
            [(i, 1, p) for i, p in zip(vals, val_prom)]
    )
    extrema.sort(key=lambda x: x[0])
    if not extrema:
        return labels

    # --------------------------------------------------
    # Enforce alternation
    # --------------------------------------------------
    def enforce_alternation(ext):
        out = ext[:]
        changed = True
        while changed:
            changed = False
            i = 0
            while i < len(out) - 1:
                if out[i][1] == out[i + 1][1]:
                    out.pop(i if out[i][2] < out[i + 1][2] else i + 1)
                    changed = True
                else:
                    i += 1
        return out

    extrema = enforce_alternation(extrema)

    # --------------------------------------------------
    # Snap extrema to true price
    # --------------------------------------------------
    def snap(idx, typ):
        L = max(0, idx - snap_window)
        R = min(n, idx + snap_window + 1)
        if high is not None and low is not None:
            return L + (np.argmax(high[L:R]) if typ == 2 else np.argmin(low[L:R]))
        return L + (np.argmax(close[L:R]) if typ == 2 else np.argmin(close[L:R]))

    snapped = {}
    for i, t, p in extrema:
        j = snap(i, t)
        if (j, t) not in snapped or p > snapped[(j, t)][2]:
            snapped[(j, t)] = (j, t, p)

    extrema = enforce_alternation(sorted(snapped.values(), key=lambda x: x[0]))

    # --------------------------------------------------
    # Prune micro legs
    # --------------------------------------------------
    final_ext = []
    for i, t, _ in extrema:
        if not final_ext:
            final_ext.append((i, t))
            continue

        pi, _, = final_ext[-1]
        leg = abs(close[i] - close[pi])
        thr = max(
            min_dev_pct * close[i],
            min_dev_sigma * max(local_vol_price[i], 1e-12),
        )
        if leg >= thr:
            final_ext.append((i, t))

    if len(final_ext) < 2:
        return labels

    # --------------------------------------------------
    # Base trend labeling
    # --------------------------------------------------
    trend = np.zeros(n, dtype=int)

    for (i0, t0), (i1, t1) in zip(final_ext[:-1], final_ext[1:]):
        if t0 == 1 and t1 == 2:
            trend[i0:i1] = 1
        elif t0 == 2 and t1 == 1:
            trend[i0:i1] = 2
        trend[i0] = t0

    last_i, last_t = final_ext[-1]
    trend[last_i:] = last_t

    # --------------------------------------------------
    # Flat detection (independent pass)
    # --------------------------------------------------
    flat = np.zeros(n, dtype=bool)
    w = flat_slope_window

    for j in range(w, n):
        seg = close[j - w:j + 1]
        if seg.max() - seg.min() < flat_slope_mult * local_vol_price[j]:
            flat[j - w:j + 1] = True

    # --------------------------------------------------
    # Final labels
    # --------------------------------------------------
    labels[:] = trend
    labels[flat] = 0

    if verbose:
        print("Label counts:", {k: int((labels == k).sum()) for k in (0, 1, 2)})
        print("Extrema kept:", len(final_ext))

    return labels